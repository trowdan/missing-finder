import random
import math
from datetime import datetime, timedelta
from typing import List
from homeward.services.video_analysis_service import VideoAnalysisService
from homeward.models.video_analysis import VideoAnalysisResult, VideoAnalysisRequest


class MockVideoAnalysisService(VideoAnalysisService):
    """Mock implementation of VideoAnalysisService for development and testing"""
    
    def __init__(self):
        self._evidence_store = set()  # Store evidence IDs
        
        # Sample AI descriptions that would realistically be generated by Gemini
        self._ai_descriptions = [
            "Individual matching subject description observed walking northbound on sidewalk. Wearing dark blue jeans and light colored upper garment. Gait pattern and physical stature consistent with missing person profile.",
            "Person of interest detected crossing street intersection. Facial recognition confidence high. Subject appears to be carrying a dark backpack, matches witness description from initial report.",
            "Individual with similar height and build observed near bus stop. Hair color and clothing style match case parameters. Subject shows signs of distress or confusion, looking around frequently.",
            "Person matching age and gender profile seen entering convenience store. Physical characteristics align with missing person description. Interaction with store clerk suggests request for assistance.",
            "Subject identified exiting public transportation. Clothing partially matches last known outfit. Individual appears disoriented, checking surroundings repeatedly before proceeding east.",
            "Person of interest observed sitting on park bench for extended period. Physical attributes consistent with case profile. Subject appears to be resting, possibly showing signs of fatigue.",
            "Individual matching description seen walking with unidentified companion. Height, build, and clothing style correspond to missing person parameters. Both subjects proceed toward residential area.",
            "Person detected near commercial district showing behavior consistent with seeking assistance. Physical characteristics match case profile. Subject approaches multiple pedestrians before continuing.",
            "Individual observed at public transit station consulting information displays. Age, gender, and physical attributes align with missing person description. Subject appears uncertain about direction.",
            "Person matching case parameters identified near healthcare facility. Physical stature and clothing partially match witness descriptions. Subject walks purposefully toward main entrance."
        ]
        
        self._camera_types = ["Traffic", "Security", "CCTV", "Mobile"]
        self._street_names = [
            "Main Street", "King Street", "Queen Street", "University Avenue", 
            "Bay Street", "Yonge Street", "College Street", "Dundas Street",
            "Bloor Street", "Front Street", "Adelaide Street", "Richmond Street"
        ]
    
    def analyze_videos(self, request: VideoAnalysisRequest) -> List[VideoAnalysisResult]:
        """Perform mock AI video analysis and return realistic results"""
        results = []
        
        # Generate realistic number of results (2-8)
        num_results = random.randint(2, 8)
        
        for i in range(num_results):
            # Generate realistic timestamp within the requested range
            time_diff = request.end_date - request.start_date
            random_time = request.start_date + timedelta(
                seconds=random.randint(0, int(time_diff.total_seconds()))
            )
            
            # Generate location within search radius
            lat, lon, address, distance = self._generate_location_within_radius(
                request.last_seen_latitude, 
                request.last_seen_longitude, 
                request.search_radius_km
            )
            
            # Generate realistic confidence score (higher confidence = closer to last seen)
            max_confidence = max(0.5, 1.0 - (distance / request.search_radius_km) * 0.4)
            confidence = random.uniform(0.6, max_confidence)
            
            # Generate camera info
            camera_type = random.choice(self._camera_types)
            camera_id = f"{camera_type.upper()}-{random.randint(1000, 9999)}"
            
            # Generate video URL (would be real GCS URLs in production)
            video_url = f"https://storage.googleapis.com/homeward-videos/{camera_id}_{random_time.strftime('%Y%m%d_%H%M%S')}.mp4"
            
            result = VideoAnalysisResult(
                id=f"VA-{request.case_id}-{i+1:03d}",
                timestamp=random_time,
                latitude=lat,
                longitude=lon,
                address=address,
                distance_from_last_seen=distance,
                video_url=video_url,
                confidence_score=confidence,
                ai_description=random.choice(self._ai_descriptions),
                camera_id=camera_id,
                camera_type=camera_type
            )
            
            results.append(result)
        
        # Sort by confidence score (highest first)
        results.sort(key=lambda x: x.confidence_score, reverse=True)
        
        return results
    
    def add_to_evidence(self, result_id: str, case_id: str) -> bool:
        """Add analysis result to case evidence (mock implementation)"""
        evidence_key = f"{case_id}:{result_id}"
        self._evidence_store.add(evidence_key)
        return True
    
    def get_video_url(self, result_id: str) -> str:
        """Get the video URL for a specific analysis result (mock implementation)"""
        # In a real implementation, this would query the database
        return f"https://storage.googleapis.com/homeward-videos/video_{result_id}.mp4"
    
    def _generate_location_within_radius(self, center_lat: float, center_lon: float, radius_km: float):
        """Generate a random location within the specified radius"""
        # Generate random distance and bearing
        distance = random.uniform(0.1, radius_km)
        bearing = random.uniform(0, 360)
        
        # Convert to radians
        lat1 = math.radians(center_lat)
        lon1 = math.radians(center_lon)
        bearing_rad = math.radians(bearing)
        
        # Earth's radius in km
        R = 6371
        
        # Calculate new coordinates
        lat2 = math.asin(
            math.sin(lat1) * math.cos(distance / R) +
            math.cos(lat1) * math.sin(distance / R) * math.cos(bearing_rad)
        )
        
        lon2 = lon1 + math.atan2(
            math.sin(bearing_rad) * math.sin(distance / R) * math.cos(lat1),
            math.cos(distance / R) - math.sin(lat1) * math.sin(lat2)
        )
        
        # Convert back to degrees
        new_lat = math.degrees(lat2)
        new_lon = math.degrees(lon2)
        
        # Generate realistic address
        street_number = random.randint(100, 9999)
        street_name = random.choice(self._street_names)
        address = f"{street_number} {street_name}, Toronto, ON"
        
        return new_lat, new_lon, address, distance